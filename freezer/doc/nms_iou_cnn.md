# 物体检测中常用的几个概念迁移学习、IOU、NMS理解

1、迁移学习

迁移学习也即所谓的有监督预训练(Supervised pre-training)，我们通常把它称之为迁移学习。比如你已经有一大堆标注好的人脸年龄分类的图片数据，训练了一个CNN，用于人脸的年龄识别。然后当你遇到新的项目任务是：人脸性别识别，那么这个时候你可以利用已经训练好的年龄识别CNN模型，去掉最后一层，然后其它的网络层参数就直接复制过来，继续进行训练。这就是所谓的迁移学习，说的简单一点就是把一个任务训练好的参数，拿到另外一个任务，作为神经网络的初始参数值,这样相比于你直接采用随机初始化的方法，精度可以有很大的提高。

图片分类标注好的训练数据非常多，但是物体检测的标注数据却很少，如何用少量的标注数据，训练高质量的模型，比如我们先对imagenet图片数据集先进行网络的图片分类训练。这个数据库有大量的标注数据。

2、IOU(交并比)

![IOU](http://img.blog.csdn.net/20161001105115541)


物体检测需要定位出物体的bounding box，就像上面的图片一样，我们不仅要定位出车辆的bounding box 我们还要识别出bounding box 里面的物体就是车辆。对于bounding box的定位精度，有一个很重要的概念，因为我们算法不可能百分百跟人工标注的数据完全匹配，因此就存在一个定位精度评价公式：IOU。 
IOU表示了bounding box 与 ground truth 的重叠度，如下图所示：

![](http://img.blog.csdn.net/20161001105341420)

矩形框A、B的一个重合度IOU计算公式为：

IOU=(A∩B)/(A∪B)
就是矩形框A、B的重叠面积占A、B并集的面积比例:

IOU=SI/(SA+SB-SI)
3、NMS

NMS也即非极大值抑制。在最近几年常见的物体检测算法（包括rcnn、sppnet、fast-rcnn、faster-rcnn等）中，最终都会从一张图片中找出很多个可能是物体的矩形框，然后为每个矩形框为做类别分类概率：

![](http://img.blog.csdn.net/20161001110746283)

就像上面的图片一样，定位一个车辆，最后算法就找出了一堆的方框，我们需要判别哪些矩形框是没用的。 
所谓非极大值抑制：先假设有6个矩形框，根据分类器类别分类概率做排序，从小到大分别属于车辆的概率分别为A、B、C、D、E、F。

(1)从最大概率矩形框F开始，分别判断A~E与F的重叠度IOU是否大于某个设定的阈值;
(2)假设B、D与F的重叠度超过阈值，那么就扔掉B、D；并标记第一个矩形框F，是我们保留下来的。
(3)从剩下的矩形框A、C、E中，选择概率最大的E，然后判断E与A、C的重叠度，重叠度大于一定的阈值，那么就扔掉；并标记E是我们保留下来的第二个矩形框。

就这样一直重复，找到所有被保留下来的矩形框。

另外一篇介绍NMS的博客
[NMS——非极大值抑制](http://blog.csdn.net/shuzfan/article/details/52711706)

NMS（non maximum suppression），中文名非极大值抑制，在很多计算机视觉任务中都有广泛应用，如：边缘检测、目标检测等。

这里主要以人脸检测中的应用为例，来说明NMS，并给出Matlab和C++示例程序。

人脸检测的一些概念

（1）绝大部分人脸检测器的核心是分类器，即给定一个尺寸固定图片，分类器判断是或者不是人脸；

（2）将分类器进化为检测器的关键是：在原始图像上从多个尺度产生窗口，并resize到固定尺寸，然后送给分类器做判断。最常用的方法是滑动窗口。

以下图为例，由于滑动窗口，同一个人可能有好几个框(每一个框都带有一个分类器得分)

![](http://img.blog.csdn.net/20160930144735714)

而我们的目标是一个人只保留一个最优的框：

于是我们就要用到非极大值抑制，来抑制那些冗余的框： 抑制的过程是一个迭代-遍历-消除的过程。

（1）将所有框的得分降序排列，选中最高分及其对应的框：

![](http://img.blog.csdn.net/20160930152040246)

（2）遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。

![](http://img.blog.csdn.net/20160930152407168)

（3）从未处理的框中继续选一个得分最高的，重复上述过程。

![](http://img.blog.csdn.net/20160930144745652)

下面给出MATLAB下的快速NMS代码，并带有详细的注释：
```matlab
%% NMS:non maximum suppression
function pick = nms(boxes,threshold,type)
% boxes: m x 5,表示有m个框，5列分别是[x1 y1 x2 y2 score]
% threshold: IOU阈值
% type：IOU阈值的定义类型

    % 输入为空，则直接返回
    if isempty(boxes)
      pick = [];
      return;
    end

    % 依次取出左上角和右下角坐标以及分类器得分(置信度)
    x1 = boxes(:,1);
    y1 = boxes(:,2);
    x2 = boxes(:,3);
    y2 = boxes(:,4);
    s = boxes(:,5);

    % 计算每一个框的面积
    area = (x2-x1+1) .* (y2-y1+1);

    %将得分升序排列
    [vals, I] = sort(s);

    %初始化
    pick = s*0;
    counter = 1;

    % 循环直至所有框处理完成
    while ~isempty(I)
        last = length(I); %当前剩余框的数量
        i = I(last);%选中最后一个，即得分最高的框
        pick(counter) = i;
        counter = counter + 1;  

        %计算相交面积
        xx1 = max(x1(i), x1(I(1:last-1)));
        yy1 = max(y1(i), y1(I(1:last-1)));
        xx2 = min(x2(i), x2(I(1:last-1)));
        yy2 = min(y2(i), y2(I(1:last-1)));  
        w = max(0.0, xx2-xx1+1);
        h = max(0.0, yy2-yy1+1); 
        inter = w.*h;

        %不同定义下的IOU
        if strcmp(type,'Min')
            %重叠面积与最小框面积的比值
            o = inter ./ min(area(i),area(I(1:last-1)));
        else
            %交集/并集
            o = inter ./ (area(i) + area(I(1:last-1)) - inter);
        end

        %保留所有重叠面积小于阈值的框，留作下次处理
        I = I(find(o<=threshold));
    end
    pick = pick(1:(counter-1));
end
```